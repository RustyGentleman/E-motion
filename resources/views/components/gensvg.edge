@pushOnceTo('css')
	<style>
		.affect-svg {
			overflow: visible;
			g {
				overflow: visible;
			}
			g.bg {
				path, polygon, ellipse {
					opacity: .5;
					&:not(:first-child) {
						mix-blend-mode: color-dodge;
					}
				}
			}
		}
	</style>
@end
@pushOnceTo('js')
	<script class="svg-replace" data-input="{{ input }}">
		/**
		* generateSquareSVG(input, size = 256, opts = {})
		* - input: string (seed)
		* - size: px square dimension
		* - opts: {cells: number (grid N), bg: string|null, padding: number (px), seedOffset: number}
		*
		* Returns: SVG markup string (deterministic)
		*/

		function fnv1a32(str) {
			let h = 0x811c9dc5 >>> 0
			for (let i = 0; i < str.length; i++) {
				h ^= str.charCodeAt(i)
				h = Math.imul(h, 0x01000193) >>> 0
			}
			return h >>> 0
		}
		// Tiny PRNG: mulberry32
		function mulberry32(a) {
			return function () {
				a |= 0
				a = (a + 0x6D2B79F5) | 0
				let t = Math.imul(a ^ (a >>> 15), 1 | a)
				t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t
				return ((t ^ (t >>> 14)) >>> 0) / 4294967296
			}
		}
		function hsl(h, s, l) {
			return `hsl(${(h % 360 + 360) % 360} ${s}% ${l}%)`
		}
		function generate(input, size = 256, opts = {}) {
			// -----------------------
			// Setup & deterministic PRNG
			// -----------------------
			const categories = Array.isArray(opts.categories) ? opts.categories.map(String) : []
			let rarity = 'common'
			if (categories.includes('exotic')) rarity = 'exotic'
			else if (categories.includes('rare')) rarity = 'rare'
			else if (categories.includes('common')) rarity = 'common'

			const effectList = ['positive', 'negative', 'ambiguous', 'other']
			const effect = effectList.find((e) => categories.includes(e)) || 'other'

			const knownNatures = ['social', 'introspective', 'cognitive', 'environmental', 'temporal', 'instinctual', 'existential']
			const natures = categories.filter((c) => knownNatures.includes(c))

			const seed = fnv1a32(String(input))
			const rnd = mulberry32(seed)
			const r = () => rnd()

			const cx = size / 2
			const cy = size / 2

			// -----------------------
			// Palette & profiles
			// -----------------------
			let baseHue = Math.floor(r() * 360)
			if (effect === 'positive') baseHue = (baseHue + 18) % 360
			if (effect === 'negative') baseHue = (baseHue + 200) % 360
			if (effect === 'ambiguous') baseHue = (baseHue + 300) % 360

			if (natures.includes('environmental')) baseHue = (baseHue + 8) % 360
			if (natures.includes('temporal')) baseHue = (baseHue + 32) % 360
			if (natures.includes('existential')) baseHue = (baseHue + 6) % 360

			// background hue full-randomized (contrasts foreground)
			const bgHue = Math.floor(r() * 360)

			const effectProfile = {
				positive: { sat: 64, light: 54, bgSat: 92, bgLight: 50 },
				negative: { sat: 48, light: 36, bgSat: 88, bgLight: 36 },
				ambiguous: { sat: 34, light: 50, bgSat: 84, bgLight: 44 },
				other: { sat: 54, light: 46, bgSat: 90, bgLight: 42 },
			}[effect] || { sat: 50, light: 48, bgSat: 90, bgLight: 42 }

			const mainColor = hsl(baseHue, effectProfile.sat, effectProfile.light, 1)
			const accentColor = hsl((baseHue + 24) % 360, Math.max(40, effectProfile.sat + 6), Math.max(36, effectProfile.light - 6), 1)

			// provide a third color for rare/exotic
			const hasThird = rarity === 'rare' || rarity === 'exotic'
			const accentColor2 = hasThird ? hsl((baseHue + 58 + Math.floor(r() * 40)) % 360, Math.max(36, effectProfile.sat - 6), Math.max(34, effectProfile.light - 10), 1) : null

			// saturated, semi-transparent bg fills (now truly randomized hues)
			const bgFillA = hsl((bgHue + Math.floor(r() * 60)) % 360, 96, Math.max(18, effectProfile.bgLight - 10), 0.48)
			const bgFillB = hsl((bgHue + 60 + Math.floor(r() * 60)) % 360, 92, Math.max(16, effectProfile.bgLight - 12), 0.44)
			const bgFillC = hsl((bgHue + 150 + Math.floor(r() * 40)) % 360, 96, Math.max(12, effectProfile.bgLight - 18), 0.36)

			// -----------------------
			// Sizes & complexity by rarity
			// -----------------------
			const rarityFactor = rarity === 'common' ? 1 : rarity === 'rare' ? 1.5 : 2
			const bgScale = opts.bgScale ?? 0.5 * (1 + (rarity === 'exotic' ? 0.1 : 0))
			const fgScale = opts.fgScale ?? (0.4 + r() * 0.12)
			const bgRadius = Math.round(size * bgScale)
			const fgSize = Math.round(size * fgScale)

			const bgPointsBase = 6 + Math.floor(r() * 6)
			const bgPoints = Math.max(5, Math.round(bgPointsBase * rarityFactor))
			const bgLayers = 1 + (rarity === 'rare' ? 1 : 0) + (rarity === 'exotic'? 1 : 0)

			// -----------------------
			// Defs: gradients
			// -----------------------
			const defs = []
			const useGrad = r() > 0.4
			const gradIdA = `gA${seed & 0xffff}`
			const gradIdB = `gB${(seed >> 8) & 0xffff}`
			if (useGrad) {
				defs.push(
					`<linearGradient id="${gradIdA}" x1="0" x2="1" y1="0" y2="1">
					<stop offset="0%" stop-color="${hsl((bgHue + Math.floor(r()*40))%360, 92, effectProfile.bgLight)}" stop-opacity="0.92"/>
					<stop offset="100%" stop-color="${hsl((bgHue + 120 + Math.floor(r()*40))%360, 88, Math.max(8,effectProfile.bgLight-6))}" stop-opacity="0.6"/>
					</linearGradient>`
				)
				defs.push(
					`<radialGradient id="${gradIdB}" cx="0.5" cy="0.45" r="0.6">
					<stop offset="0%" stop-color="${hsl(baseHue, effectProfile.sat, Math.min(86, effectProfile.light+14))}" stop-opacity="0.96"/>
					<stop offset="100%" stop-color="${hsl((baseHue+40)%360, Math.max(28,effectProfile.sat-18), Math.max(18,effectProfile.light-20))}" stop-opacity="0.92"/>
					</radialGradient>`
				)
			}

			// -----------------------
			// Helpers
			// -----------------------
			function radialPolygonPoints(pointCount, radius, jitterAmp = 0.18, angleOffset = 0) {
				const pts = []
				radius = Number(radius) || 0
				for (let i = 0; i < pointCount; i++) {
					const angle = (i / pointCount) * Math.PI * 2 + angleOffset + (r() - 0.5) * 0.12
					const jitter = 1 + (r() - 0.5) * jitterAmp
					const rx = Math.cos(angle) * radius * jitter
					const ry = Math.sin(angle) * radius * (0.86 + (r() - 0.5) * 0.28)
					pts.push(`${(cx + rx).toFixed(2)},${(cy + ry).toFixed(2)}`)
				}
				return pts.join(' ')
			}
			function regularPolygonPoints(cx_, cy_, pts, radius) {
				const arr = []
				radius = Number(radius) || 0
				for (let i = 0; i < pts; i++) {
					const a = (i / pts) * Math.PI * 2
					const x = cx_ + Math.cos(a) * radius
					const y = cy_ + Math.sin(a) * radius
					arr.push(`${x.toFixed(2)},${y.toFixed(2)}`)
				}
				return arr.join(' ')
			}
			function jitterBlobPath(cx_, cy_, radius, points = 7, jitter = 0.22, rotate = 0, fillColor = null) {
				radius = Number(radius) || 0
				cx_ = Number(cx_) || 0
				cy_ = Number(cy_) || 0
				points = Math.max(3, Number(points) || 7)
				jitter = Number(jitter) || 0.22
				rotate = Number(rotate) || 0

				const pts = []
				for (let i = 0; i < points; i++) {
					const angle = (i / points) * Math.PI * 2
					const rj = radius * (0.7 + (r() - 0.5) * jitter)
					const x = cx_ + Math.cos(angle) * rj
					const y = cy_ + Math.sin(angle) * rj
					// explicitly coerce to numbers
					pts.push({ x: Number(x), y: Number(y) })
				}

				if (pts.length < 2) return ''

				let path = `M ${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)} `
				for (let i = 1; i <= pts.length; i++) {
					const p = pts[i % pts.length]
					const prev = pts[i - 1]
					const midx = ((prev.x + p.x) / 2).toFixed(2)
					const midy = ((prev.y + p.y) / 2).toFixed(2)
					path += `Q ${prev.x.toFixed(2)} ${prev.y.toFixed(2)} ${midx} ${midy} `
				}

				if (fillColor) {
					return `<path d="${path} Z" transform="rotate(${rotate} ${cx_} ${cy_})" fill="${fillColor}" stroke="none"/>`
				}
				return `<path d="${path} Z" transform="rotate(${rotate} ${cx_} ${cy_})" fill-opacity="0.98" stroke="none"/>`
			}

			// -----------------------
			// Background generators (array) — pick from these for variety
			// -----------------------
			const backgroundGenerators = [
				// polygonal radial (existing)
				function (layer) {
					const scaleLayer = 1 - layer * 0.08
					const radius = Math.round(bgRadius * scaleLayer * (0.86 + (r() - 0.5) * 0.12))
					const jitterAmp = 0.14 + r() * 0.12 + (rarity === 'exotic' ? 0.06 : 0)
					const pts = radialPolygonPoints(bgPoints + Math.floor(r() * 3), radius, jitterAmp, r() * 0.6)
					const fill = useGrad && r() > 0.45 ? `url(#${gradIdA})` : (r() > 0.5 ? bgFillA : bgFillB)
					const dx = ((r() - 0.5) * size * 0.1 * (1 + layer * 0.3)).toFixed(2)
					const dy = ((r() - 0.5) * size * 0.1 * (1 + layer * 0.3)).toFixed(2)
					const dur = (6 + r() * 6 + layer * 1.2).toFixed(2)
					const ks = '0.25 0.1 0.25 1'
					return `<polygon points="${pts}" fill="${fill}" opacity="${(0.48 - layer * 0.08).toFixed(2)}"><animateTransform attributeName="transform" type="translate" dur="${dur}s" values="0 0; ${dx} ${dy}; 0 0" repeatCount="indefinite" calcMode="spline" keySplines="${ks};${ks}" keyTimes="0;0.5;1"/></polygon>`
				},

				// spiky star — uses alternating radii to create star-ish polygon
				/*function (layer) {
					const spikes = Math.max(6, Math.round(bgPoints * (0.9 + r() * 0.6)))
					const outer = Math.round(bgRadius * (1 - layer * 0.08) * (0.9 + (r() - 0.5) * 0.12))
					const inner = Math.round(outer * (0.45 + r() * 0.22))
					const pts = []
					for (let i = 0; i < spikes * 2; i++) {
					const a = (i / (spikes * 2)) * Math.PI * 2
					const rad = i % 2 === 0 ? outer : inner * (0.9 + (r() - 0.5) * 0.12)
					const x = cx + Math.cos(a) * rad
					const y = cy + Math.sin(a) * rad
					pts.push(`${x.toFixed(2)},${y.toFixed(2)}`)
					}
					const fill = r() > 0.5 ? bgFillB : bgFillC
					const dx = ((r() - 0.5) * size * 0.1).toFixed(2)
					const dy = ((r() - 0.5) * size * 0.1).toFixed(2)
					const dur = (8 + r() * 6 + layer).toFixed(2)
					return `<g><polygon points="${pts.join(' ')}" fill="${fill}" opacity="${(0.44 - layer * 0.06).toFixed(2)}"><animateTransform attributeName="transform" type="translate" dur="${dur}s" values="0 0; ${dx} ${dy}; 0 0" repeatCount="indefinite"/></polygon></g>`
				},*/

				// concentric rings — a few ellipses layered
				function (layer) {
					const rings = 2 + Math.floor(r() * 2)
					const parts = []
					for (let k = 0; k < rings; k++) {
					const rr = Math.round(bgRadius * (0.6 + k * 0.18) * (1 - layer * 0.06) * (0.9 + (r()-0.5)*0.12))
					const ry = Math.round(rr * (0.8 + (r()-0.5)*0.22))
					const rot = Math.round((r()-0.5)*18)
					const fill = r() > 0.4 ? bgFillA : bgFillC
					parts.push(`<ellipse cx="${cx}" cy="${cy}" rx="${rr}" ry="${ry}" transform="rotate(${rot} ${cx} ${cy})" fill="${fill}" opacity="${(0.18 + k*0.06).toFixed(2)}"/>`)
					}
					return `${parts.join('')}`
				},

				// smooth wavy ring (path) — generated from jittered points but rendered as smooth path
				function (layer) {
					const pc = Math.max(6, bgPoints + Math.floor(r()*3))
					const radius = Math.round(bgRadius * (0.9 - layer * 0.08))
					// create pts around circle
					const pts = []
					for (let i = 0; i < pc; i++) {
					const a = (i / pc) * Math.PI * 2
					const rad = radius * (0.82 + (r()-0.5)*0.28)
					pts.push({ x: cx + Math.cos(a) * rad, y: cy + Math.sin(a) * rad })
					}
					// smooth path: use quadratic midpoints
					let path = `M ${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)} `
					for (let i = 1; i <= pts.length; i++) {
					const p = pts[i % pts.length]
					const prev = pts[i-1]
					const mx = ((prev.x + p.x)/2).toFixed(2)
					const my = ((prev.y + p.y)/2).toFixed(2)
					path += `Q ${prev.x.toFixed(2)} ${prev.y.toFixed(2)} ${mx} ${my} `
					}
					const fill = r() > 0.5 ? bgFillB : (useGrad ? `url(#${gradIdA})` : bgFillA)
					const dur = (6 + r()*5 + layer).toFixed(2)
					const dx = ((r()-0.5) * size * 0.1).toFixed(2)
					const dy = ((r()-0.5) * size * 0.1).toFixed(2)
					return `<path d="${path} Z" fill="${fill}" opacity="${(0.42 - layer*0.06).toFixed(2)}"><animateTransform attributeName="transform" type="translate" dur="${dur}s" values="0 0; ${dx} ${dy}; 0 0" repeatCount="indefinite"/></path>`
				},

				// organic multi-blob (several jitterBlobPath overlays)
				function (layer) {
					const parts = []
					const blobs = 1 + Math.floor(r()*2)
					for (let b = 0; b < blobs; b++) {
					const radius = Math.round(bgRadius * (0.74 + b*0.06) * (0.88 + (r()-0.5)*0.16))
					const pts = 6 + Math.floor(r()*5)
					const fill = (b%2===0) ? bgFillA : bgFillC
					parts.push(jitterBlobPath(cx, cy, radius, pts, 0.22 + r()*0.12, Math.round((r()-0.5)*18), fill))
					}
					return `${parts.join('')}`
				}
			]

			// -----------------------
			// Build background by selecting generator per layer
			// -----------------------
			const bgPolygons = []
			for (let layer = 0; layer < bgLayers; layer++) {
				const gen = backgroundGenerators[Math.floor(r() * backgroundGenerators.length)]
				bgPolygons.push(gen(layer))
			}

			// -----------------------
			// Foreground generators (unchanged structure, but use 3-color when available)
			// -----------------------
			const fgGenerators = [
				function () { // layered polygons
					const shapes = []
					const layers = 2 + (r() > 0.6 ? 1 : 0)
					for (let i = 0; i < layers; i++) {
					const pts = 3 + Math.floor(r() * 5)
					const scale = 1 - i * 0.28
					const rad = fgSize * 0.5 * scale
					const rot = Math.round((r() - 0.5) * 28)
					let fill = i === 0 ? (useGrad && r() > 0.6 ? `url(#${gradIdB})` : mainColor) : (i % 2 ? accentColor : (accentColor2 || hsl(baseHue - 12, Math.max(8, effectProfile.sat - 10), effectProfile.light + 8)))
					shapes.push(`<polygon points="${regularPolygonPoints(cx, cy, pts, rad)}" transform="rotate(${rot} ${cx} ${cy})" fill="${fill}" opacity="${(0.98 - i * 0.16).toFixed(2)}" />`)
					}
					return shapes.join('\n')
				},

				function () { // blob + emblem
					const shapes = []
					const blobRadius = fgSize * (0.44 + r() * 0.08)
					const blobFill = useGrad && r() > 0.5 ? `url(#${gradIdB})` : mainColor
					shapes.push(jitterBlobPath(cx, cy, blobRadius, 7 + Math.floor(r() * 4), 0.26 + r() * 0.16, Math.round((r() - 0.5) * 16), blobFill))
					const emblem = `<polygon points="${regularPolygonPoints(cx, cy, 4 + Math.floor(r() * 3), fgSize * 0.2)}" transform="rotate(${Math.round((r()-0.5)*44)} ${cx} ${cy})" fill="${accentColor2 || accentColor}" opacity="0.98"/>`
					shapes.push(emblem)
					return shapes.join('\n')
				},

				function () { // ring + glyph
					const shapes = []
					const ringR = fgSize * 0.5
					const ringW = Math.max(3, Math.round(fgSize * 0.06))
					shapes.push(`<circle cx="${cx}" cy="${cy}" r="${ringR}" stroke="${accentColor2 || accentColor}" stroke-width="${ringW}" fill="none" stroke-opacity="0.96" />`)
					const glyph = `<polygon points="${regularPolygonPoints(cx, cy, 3 + Math.floor(r() * 4), ringR * 0.48)}" transform="rotate(${Math.round((r()-0.5)*40)} ${cx} ${cy})" fill="${mainColor}" opacity="0.98"/>`
					shapes.push(glyph)
					return shapes.join('\n')
				},

				function () { // organic stacked/maybe smooth blobs
					const shapes = []
					for (let i = 0; i < 3; i++) {
					const rx = Math.round(fgSize * (0.28 - i * 0.06))
					const ry = Math.round(rx * (0.72 + (r() - 0.5) * 0.18))
					const rot = Math.round((r() - 0.5) * 24)
					const fill = i === 0 ? mainColor : (accentColor2 && r() > 0.5 ? accentColor2 : accentColor)
					if (r() > 0.45) {
						shapes.push(jitterBlobPath(cx, cy, rx, 6 + Math.floor(r() * 4), 0.22 + r() * 0.18, rot, fill))
					} else {
						shapes.push(`<ellipse cx="${cx}" cy="${cy}" rx="${rx}" ry="${ry}" fill="${fill}" opacity="${(0.94 - i * 0.16).toFixed(2)}" transform="rotate(${rot} ${cx} ${cy})"/>`)
					}
					}
					return shapes.join('\n')
				}
			]

			const fgChoice = Math.floor(r() * fgGenerators.length)
			const fgContent = fgGenerators[fgChoice]()

			const fgDur = (3.0 + r() * 2.8 / rarityFactor).toFixed(2)
			const fgRotateDur = (4 + r() * 3).toFixed(2)
			const fgGroup = `<g>${fgContent}
				<animateTransform attributeName="transform" attributeType="XML" type="scale" values="1;1.02;1" dur="${fgDur}s" repeatCount="indefinite" calcMode="spline" keySplines="0.25 0.1 0.25 1;0.25 0.1 0.25 1"/>
				<animateTransform attributeName="transform" attributeType="XML" type="rotate" additive="sum" values="0;${((r() - 0.5) * 6).toFixed(2)};0" dur="${fgRotateDur}s" repeatCount="indefinite" calcMode="spline" keySplines="0.25 0.1 0.25 1"/>
			</g>`

			// -----------------------
			// Secondary elements: orbiters + anchored
			// -----------------------
			const smallCount = Math.round(4 + r() * 5 * rarityFactor)
			const secondaryElems = []

			const margin = Math.max(8, Math.round(size * 0.03))
			const maxOrbitRadius = Math.max((size / 2) - margin, fgSize * 0.6)
			const minOrbitRadius = Math.round(fgSize * 0.45)

			for (let i = 0; i < smallCount; i++) {
				const angle = (i / smallCount) * Math.PI * 2 + (r() - 0.5) * 0.8
				const rel = 0.45 + r() * 0.40
				let dist = Math.round(maxOrbitRadius * rel)
				dist = Math.max(minOrbitRadius, Math.min(dist, maxOrbitRadius))
				const sSz = Math.round(size * (0.01 + r() * 0.04))
				const colorChoice = r() > 0.5 ? (accentColor2 || accentColor) : hsl(baseHue + 8, Math.max(36, effectProfile.sat - 4), Math.max(38, effectProfile.light - 6))
				const dur = (3.4 + r() * 4.6 * (1 + (rarity === 'exotic' ? 0.45 : 0))).toFixed(2)

				if (r() > 0.45 || (i === 0? 1 : 0)) {
					const orbitDir = r() > 0.5 ? 1 : -1
					const orbitDur = (6 + r() * 6 * (1 + (rarity === 'exotic' ? 0.6 : 0))).toFixed(2)
					const startDeg = ((angle * 180) / Math.PI)

					const useBlob = r() > 0.6
					const shapeHtml = useBlob
					? jitterBlobPath(0, 0, sSz * (1 + r() * 0.4), 5 + Math.floor(r() * 3), 0.22, 0, colorChoice)
					: `<circle cx="0" cy="0" r="${sSz}" fill="${colorChoice}" opacity="0.96"/>`

					secondaryElems.push(`
					<g>
						<g transform="translate(${cx} ${cy})">
							<g transform="rotate(${startDeg})">
							<animateTransform attributeName="transform" type="rotate" from="${startDeg}" to="${startDeg + orbitDir * 360}" dur="${orbitDur}s" repeatCount="indefinite"/>
							<g transform="translate(${dist} 0)">
								<g>
									${shapeHtml}
								</g>
							</g>
							</g>
						</g>
					</g>
					`)
				} else {
					const ax = (cx + Math.cos(angle) * (fgSize * (0.64 + r() * 0.46))).toFixed(2)
					const ay = (cy + Math.sin(angle) * (fgSize * (0.64 + r() * 0.46))).toFixed(2)
					const dx = ((r() - 0.5) * size * 0.1).toFixed(2)
					const dy = ((r() - 0.5) * size * 0.1).toFixed(2)
					secondaryElems.push(`
					<g transform="translate(0,0)">
						<circle cx="${ax}" cy="${ay}" r="${sSz}" fill="${colorChoice}" opacity="0.96"/>
						<animateTransform attributeName="transform" type="translate" dur="${dur}s" values="0 0; ${dx} ${dy}; 0 0" repeatCount="indefinite" calcMode="spline" keySplines="0.2 0 0 1;0.2 0 0 1"/>
					</g>
					`)
				}
			}

			// -----------------------
			// Exotic: extra tiny "star" field (more numerous, some white)
			// -----------------------
			const tinyStars = []
			if (rarity === 'exotic') {
				const extraCount = Math.round(6 + r() * 12)
				for (let i = 0; i < extraCount; i++) {
					const ax = (cx + (r() - 0.5) * size * 0.9).toFixed(2)
					const ay = (cy + (r() - 0.5) * size * 0.9).toFixed(2)
					const s = (0.6 + r() * 1.2).toFixed(2)
					const whiteChance = r() > 0.7
					const col = whiteChance ? 'white' : (r() > 0.5 ? accentColor2 || accentColor : hsl(baseHue + 12, Math.max(38, effectProfile.sat - 6), Math.max(72, effectProfile.light + 8)))
					const dur = (1 + r() * 6).toFixed(2)
					tinyStars.push(`<circle cx="${ax}" cy="${ay}" r="${s}" fill="${col}" opacity="${(whiteChance ? 0.98 : 0.92)}"><animate attributeName="r" dur="${dur}s" values="${s};${(Number(s)*0.5).toFixed(2)};${s}" repeatCount="indefinite"/></circle>`)
				}
			}

			const svgParts = []
			//svgParts.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" role="img" aria-label="${escapeXml(input)}">`)
			if (defs.length) svgParts.push(`<defs>${defs.join('\n')}</defs>`)

			// background
			svgParts.push(`<g class="bg">${bgPolygons.join('\n')}</g>`)

			// exotic tiny stars behind/around
			if (tinyStars.length) svgParts.push(`<g class="stars">${tinyStars.join('\n')}</g>`)

			// secondaries (orbiters/anchored)
			svgParts.push(`<g class="sec">${secondaryElems.join('\n')}</g>`)

			// foreground (top)
			svgParts.push(`<g class="fg" transform="translate(0 0)">${fgGroup}</g>`)

			//svgParts.push(`</svg>`)

			return svgParts.join('\n')
			}
		// Escape a string for inclusion in aria-label
		function escapeXml(str) {
			return String(str).replace(/[&<>'"]/g, function (c) {
				return {'&':'&amp;','<':'&lt;','>':'&gt;',"'":'&apos;','"':'&quot;'}[c]
			})
		}
		// Helper: convert SVG string to data URL suitable for <img src="...">
		function svgToDataUrl(svg) {
			// encodeURIComponent for robust handling (keeps it ASCII-safe)
			return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`
		}

		const map = new Map()
		window.addEventListener('load', () => {
			console.time('SVG generation')
			for (const svg of document.querySelectorAll('svg[data-input][data-categories]')) {
				if (!svg.dataset.input || !svg.dataset.categories)
					continue
				const dataset = { input: svg.dataset.input, size: svg.dataset.size || 256, categories: svg.dataset.categories }
				const key = `${dataset.input}${dataset.size}${dataset.categories}`
				if (map.has(key)) {
					svg.innerHTML = map.get(key)
					svg.setAttribute('width', dataset.size)
					svg.setAttribute('height', dataset.size)
					continue
				}
				const code = generate(dataset.input, dataset.size, { categories: dataset.categories.split(',') })
				map.set(key, code)
				svg.innerHTML = code
				svg.setAttribute('width', dataset.size)
				svg.setAttribute('height', dataset.size)
			}
			console.timeEnd('SVG generation')
		})
	</script>
@end

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 {{ size }} {{ size }}" role="img" data-input="{{ input }}" data-size="{{ size || 256 }}" data-categories="{{ affect?.categories || categories || '' }}" {{ $props.only(['class', 'id']).merge({ class: ['affect-svg', 'pad-2'] }).toAttrs() }} width="{{ size }}" height="{{ size }}"></svg>